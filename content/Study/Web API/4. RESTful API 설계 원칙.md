RESTful API는 웹의 장점을 최대한 활용하여 유연하고 확장 가능한 시스템을 구축하기 위한 아키텍처 스타일이다. 단순히 HTTP 프로토콜을 사용하는 것을 넘어, 몇 가지 핵심 원칙을 따름으로써 진정한 RESTful API를 설계할 수 있다.

---

## 안전성 & 멱등성

[[2. HTTP 프로토콜.md#http-메서드|HTTP 메서드]]의 특성을 이해하고 올바르게 사용하는 것은 RESTful API 설계의 기본이다. 특히 안전성(Safety)과 멱등성(Idempotency)은 API의 예측 가능성과 신뢰성을 높이는 중요한 개념이다.

###### 안전한 메서드 (Safe Methods)
* 호출해도 리소스의 **상태를 변경하지 않는** 메서드를 의미한다. 즉, 서버의 데이터를 수정하지 않고 조회만 수행한다.
* 대표적으로 `GET`, `HEAD`, `OPTIONS`가 안전한 메서드에 해당한다.
* 안전한 메서드는 클라이언트나 중간 프록시 서버에서 캐싱 등의 최적화를 수행하는 데 중요한 근거가 된다.

###### 멱등성 있는 메서드 (Idempotent Methods)
* 동일한 요청을 한 번 보내든 여러 번 보내든 **결과가 같은** 메서드를 의미한다. 즉, 여러 번 호출해도 서버의 상태가 처음 호출했을 때와 동일하게 유지된다.
* `GET`, `HEAD`, `OPTIONS`, `PUT`, `DELETE`가 멱등성을 가진다.
    * `PUT`: 특정 리소스를 요청 본문에 담긴 내용으로 전체 교체하므로, 여러 번 호출해도 최종 결과는 동일하다. (예: `/users/123`에 사용자 정보 업데이트)
    * `DELETE`: 특정 리소스를 삭제하므로, 한 번 삭제된 후 다시 삭제 요청을 보내도 리소스는 이미 없는 상태이므로 결과는 동일하다. (예: `/users/123` 삭제)
* `POST`는 일반적으로 멱등성을 가지지 않는다. 동일한 요청을 여러 번 보내면 새로운 리소스가 계속 생성될 수 있다. (예: `POST /users`로 사용자 생성)
* `PATCH`는 멱등성을 가질 수도 있고 가지지 않을 수도 있다. 리소스의 특정 필드 값을 증가시키는 연산은 멱등성이 없지만, 특정 값으로 변경하는 연산은 멱등성을 가질 수 있다. 설계에 따라 달라진다.

###### 활용 예시
* 네트워크 오류 등으로 인해 클라이언트가 요청에 대한 응답을 받지 못했을 때, 멱등성 있는 메서드는 클라이언트가 안심하고 재시도할 수 있게 해준다. 재시도해도 서버 상태가 의도치 않게 변경되지 않기 때문이다.
* `GET`과 같은 안전한 메서드는 응답이 리소스를 변경하지 않음을 보장하므로, 클라이언트나 중간 캐시(CDN 등)에서 응답을 안전하게 캐싱하여 성능을 향상시키고 서버 부하를 줄일 수 있다.
* 반대로 `POST` 요청은 멱등성이 없으므로, 재시도 시 중복된 리소스(예: 중복 주문, 중복 게시글)가 생성될 수 있다. 이를 방지하기 위해 서버 측에서 중복 요청을 감지하거나 클라이언트에서 재시도 로직을 신중하게 구현해야 한다.

---

## HATEOAS

HATEOAS (Hypermedia as the Engine of Application State)는 REST 아키텍처의 핵심 제약 조건 중 하나로, **애플리케이션의 상태는 하이퍼미디어(링크)를 통해 전이되어야 함**을 의미한다. 즉, 클라이언트는 서버로부터 받은 응답에 포함된 **링크들을 통해** 다음에 수행할 수 있는 작업이나 관련된 리소스에 대한 정보를 얻고, 이를 통해 API와 **상호작용**해야 한다.

###### 목표
클라이언트와 서버 간의 **결합도(Coupling)를 낮추는 것**이다. 클라이언트는 URI 구조를 미리 알 필요 없이, 서버가 제공하는 링크를 따라가기만 하면 된다.

이를 통해 서버는 API의 **URI 구조를 변경하더라도** 기존 클라이언트에 미치는 **영향을 최소화**할 수 있다.

###### 구현
응답 데이터 내에 **관련된 작업을 수행할 수 있는 URI 링크**를 포함시킨다. 주로 JSON 응답 내에 `_links` (HAL: Hypertext Application Language 규격) 또는 유사한 필드를 사용하여 표현한다.
```json
{
    "orderId": 123,
    "status": "pending",
    "total": 50.00,
    "_links": {
        "self": { "href": "/orders/123" },
        "payment": { "href": "/orders/123/payment" },
        "cancel": { "href": "/orders/123/cancel" },
        "customer": { "href": "/customers/456" }
    }
}
```
위 예시에서 클라이언트는 `/orders/123` 주문에 대해 현재 '결제(`payment`)'나 '취소(`cancel`)' 작업을 수행할 수 있으며, 관련 고객 정보(`customer`)를 조회할 수 있음을 응답 내 링크를 통해 알 수 있다.

###### 장점
* **API 발견성 향상**: 클라이언트는 응답을 통해 가능한 다음 액션을 동적으로 파악할 수 있다.
* **유연성 및 확장성 증대**: 서버는 URI 변경에 더 자유로워지고, 새로운 기능을 추가할 때 관련 링크만 응답에 포함시키면 된다.
* **클라이언트 구현 단순화**: 클라이언트는 하드코딩된 URI 대신 동적으로 제공되는 링크를 사용하므로, 서버 변경에 덜 민감해진다.

###### 단점
* 응답 크기가 커질 수 있다.
* 모든 시나리오에 HATEOAS를 엄격하게 적용하는 것이 번거로울 수 있으며, 실제 구현 복잡도가 증가할 수 있다. 많은 현대 API들이 HATEOAS를 완전히 준수하지는 않는 경우도 많다.

---

## 페이징 · 필터링 · 정렬

대규모 데이터셋을 다루는 API에서는 클라이언트가 필요한 데이터를 효율적으로 가져갈 수 있도록 페이징, 필터링, 정렬 기능을 제공하는 것이 중요하다. 이러한 기능은 주로 **쿼리 매개변수 (Query Parameter)** 를 통해 구현된다. ([[2. HTTP 프로토콜.md#매개변수-전달-방식|매개변수 전달 방식 참고]])

###### 페이징 (Pagination)
한 번에 반환되는 데이터의 양을 제한하여 서버와 클라이언트 모두의 부하를 줄인다.
* **커서 기반 페이징 (Cursor-based Pagination)**: 마지막으로 조회된 항목의 식별자(커서)를 기준으로 다음 페이지를 요청한다. 실시간 데이터 변경에 강하고 중복 발생 가능성이 낮다. (예: `?limit=20&after=item_id_xyz`)
* **오프셋 기반 페이징 (Offset-based Pagination)**: 건너뛸 항목 수(offset)와 가져올 항목 수(limit)를 지정한다. 구현이 간단하지만, 데이터 변경 시 페이지 누락이나 중복이 발생할 수 있다. (예: `?offset=40&limit=20` 또는 `?page=3&size=20`)
* 응답에는 다음/이전 페이지 링크(HATEOAS 활용)나 전체 항목 수를 포함하여 클라이언트의 편의성을 높일 수 있다.

###### 필터링 (Filtering)
특정 조건을 만족하는 데이터만 조회할 수 있도록 한다.
* 리소스의 속성을 기준으로 필터링 조건을 쿼리 매개변수로 전달한다.
* 예시
    * `GET /products?category=electronics&status=available` (카테고리가 'electronics'이고 상태가 'available'인 상품 조회)
* 복잡한 필터링 조건(예: 범위, 논리 연산)을 지원하기 위한 규칙을 정의할 수 있다. (예: `?price_gte=100&price_lte=500`)

###### 정렬 (Sorting)
조회된 결과를 특정 속성 기준으로 오름차순 또는 내림차순으로 정렬한다.
* 정렬 기준이 되는 속성 이름과 정렬 방향(오름차순/내림차순)을 쿼리 매개변수로 전달한다.
* 예시
    * `GET /users?sort=createdAt_desc` (생성일 기준 내림차순 정렬)
    * `GET /products?sort=price_asc,name_asc` (가격 오름차순, 동일 가격 시 이름 오름차순 정렬)
* 정렬 방향을 나타내는 접두사/접미사 규칙(예: `_asc`, `_desc` 접미사 또는 `-`, `+` 접두사)을 일관되게 사용하는 것이 좋다.

이러한 기능들을 통해 클라이언트는 방대한 데이터 속에서 원하는 정보를 효율적으로 탐색하고 소비할 수 있다.

---

## 에러 모델링

API는 성공적인 응답뿐만 아니라, 요청 처리 중 발생할 수 있는 **다양한 오류 상황**에 대해서도 일관되고 예측 가능한 방식으로 응답해야 한다. 잘 정의된 에러 모델은 클라이언트가 오류를 효과적으로 처리하고 디버깅하는 데 도움을 준다.

###### 적절한 HTTP 상태 코드 사용
발생한 오류의 성격에 맞는 [[2. HTTP 프로토콜.md#HTTP-상태-코드|HTTP 상태 코드]]를 반환하는 것이 기본이다.
* **4xx (Client Error)**: 클라이언트의 잘못된 요청으로 인한 오류
    * `400 Bad Request`: 잘못된 문법 등으로 서버가 요청을 이해할 수 없음.
    * `401 Unauthorized`: 인증(Authentication)되지 않아 요청 처리가 거부.
    * `403 Forbidden`: 인가(Authorization)되지 않아 요청한 리소스에 접근 권한이 없음.
    * `404 Not Found`: 요청한 리소스를 찾을 수 없음.
* **5xx (Server Error)**: 서버 내부 문제로 인한 오류
    * `500 Internal Server Error`: 서버 내부 오류로 요청을 처리할 수 없음.
    * `503 Service Unavailable`: 일시적인 과부하 또는 점검으로 서버가 요청을 처리할 준비가 되지 않았음.

##### 일관된 에러 응답 본문 (Error Response Body)
상태 코드만으로는 충분한 정보를 전달하기 어려우므로, 에러 응답 본문에 **구체적인 오류 정보**를 포함시키는 것이 좋다. 이때, 모든 에러 응답에서 **일관된 구조**를 사용하는 것이 중요하다.
* **오류 정보 항목[^1]**:
    * `type`: 오류 유형을 식별하는 고유 코드 또는 URI (문제 해결 문서 링크 등)
    * `title`: 사람이 읽을 수 있는 간결한 오류 요약 메시지
    * `status`: HTTP 상태 코드 (응답 헤더의 상태 코드와 동일한 값)
    * `detail`: 오류에 대한 구체적인 설명
    * `instance`: 특정 오류 발생 건을 추적하기 위한 고유 식별자
* **예시**:
    ```json
    {
        "type": "https://example.com/probs/validation-error",
        "title": "Validation Failed",
        "status": 400,
        "detail": "One or more fields submitted are invalid.",
        "instance": "/users/123/update",
    }
    ```

##### 민감한 정보 노출 금지
에러 메시지에 시스템 내부 구현 정보(예: 스택 트레이스, 데이터베이스 쿼리)나 보안상 민감한 정보가 포함되지 않도록 주의해야 한다.

[^1]: [RFC 7807 (Problem Details for HTTP APIs)](https://datatracker.ietf.org/doc/html/rfc7807#section-3.1)에 정의된 표준 에러 객체 형식. JSON:API도 자체적인 에러 객체 형식을 정의함.