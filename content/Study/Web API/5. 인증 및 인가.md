API 보안의 핵심 요소는 **인증(Authentication)** 과 **인가(Authorization)** 이다.

* **인증 (Authentication)**: 사용자가 **누구인지** 확인하는 과정이다. (예: 아이디/비밀번호, 토큰 확인)
* **인가 (Authorization)**: 인증된 사용자가 특정 리소스나 기능에 **접근할 권한이 있는지** 확인하는 과정이다. (예: 관리자 권한, 읽기/쓰기 권한)

안전한 API를 구축하려면 이 두 가지 개념을 명확히 이해하고 적절한 메커니즘을 구현해야 한다.

---

## Basic Auth vs 토큰 기반 인증

API 요청 시 사용자를 인증하는 대표적인 방식에는 Basic Auth와 토큰 기반 인증이 있다.

###### Basic Authentication
* **작동 방식**: 사용자 이름과 비밀번호를 `username:password` 형식으로 합친 후, Base64로 인코딩하여 HTTP `Authorization` 헤더에 담아 보낸다.
    * `Authorization: Basic <base64-encoded-credentials>`
* **장점**: 구현이 매우 간단하다.
* **단점**:
    * Base64 인코딩은 암호화가 아니므로 쉽게 디코딩될 수 있다. **반드시 HTTPS와 함께 사용**하여 전송 중 탈취를 방지해야 한다.
    * 매 요청마다 자격 증명을 보내야 하므로 서버 부담이 발생할 수 있다.
    * 서버가 사용자 상태(세션)를 관리해야 할 수 있다.
    * 세분화된 권한 제어가 어렵다.

###### 토큰 기반 인증 (Token-based Authentication)
* **작동 방식**:
    1.  사용자가 자격 증명(예: 아이디/비밀번호)으로 로그인한다.
    2.  서버는 자격 증명을 확인하고, 사용자를 식별하는 정보와 권한 등을 담은 **토큰(Token)** 을 생성하여 클라이언트에게 발급한다.
    3.  클라이언트는 발급받은 토큰을 저장하고, 이후 API 요청 시 `Authorization` 헤더 (주로 `Bearer` 스킴 사용) 등에 토큰을 포함하여 보낸다.
        * `Authorization: Bearer <token>`
    4.  서버는 요청 헤더의 토큰을 검증하여 사용자를 인증하고 인가한다.
* **장점**:
    * **Stateless**: 서버가 사용자 세션을 유지할 필요가 없다. 토큰 자체에 필요한 정보가 포함되어 있어 서버 확장성(Scalability)[^1]에 유리하다.
    * **보안**: 비밀번호를 직접 보내지 않고 토큰을 사용하므로 더 안전하다. 토큰 만료 시간 설정, 특정 권한 부여 등이 가능하다.
    * **유연성**: 다양한 종류의 클라이언트(웹, 모바일, 서버)에 적용하기 용이하다. CORS 문제 해결에도 도움이 될 수 있다.
    * **세분화된 제어**: 토큰에 특정 권한(Scope) 정보를 담아 세밀한 접근 제어가 가능하다.
* **단점**:
    * Basic Auth보다 구현이 복잡하다.
    * 토큰 탈취 시 보안 위협이 발생할 수 있으므로, 토큰 저장 및 전송 보안에 신경 써야 한다. (예: HTTPS 필수, XSS/CSRF 방어)
    * 토큰 만료 및 갱신(Refresh) 메커니즘 구현이 필요하다.

현대 웹 API에서는 **토큰 기반 인증**이 훨씬 널리 사용된다.

---

## OAuth 2.0 & JWT

토큰 기반 인증을 구현하는 대표적인 표준과 기술로 OAuth 2.0과 JWT가 있다.

###### OAuth 2.0
**인가(Authorization)를 위한 개방형 표준 프레임워크**이다. 사용자가 자신의 계정 정보(예: 비밀번호)를 직접 노출하지 않고, 특정 애플리케이션(클라이언트)에게 자신의 리소스(예: 구글 캘린더, 페이스북 사진)에 대한 **접근 권한을 안전하게 위임**할 수 있도록 한다.

주로 **서드파티 애플리케이션에게 제한된 권한을 부여**하는 시나리오(예: 소셜 로그인, 외부 서비스 연동)에서 사용된다.

* **주요 엔티티**:
    * **Resource Owner**: 리소스 소유자 (일반 사용자).
    * **Client**: 리소스 접근 권한을 요청하는 애플리케이션 (예: 서드파티 앱).
    * **Authorization Server**: Resource Owner를 인증하고 Client에게 접근 토큰(Access Token)을 발급하는 서버.
    * **Resource Server**: 보호된 리소스를 호스팅하는 서버 (예: Google API 서버).
* **인가 승인 방식 (Grant Types)**: 클라이언트 유형과 사용 사례에 따라 다양한 방식(Authorization Code Grant, Client Credentials Grant, Implicit Grant, Resource Owner Password Credentials Grant[^2] 등)으로 접근 토큰을 획득한다. 가장 안전하고 권장되는 방식은 **Authorization Code Grant with PKCE**[^3]이다.
* **핵심**: OAuth 2.0 자체는 **인증(Authentication) 프로토콜이 아니라 인가(Authorization) 프레임워크**이다. 하지만 OpenID Connect(OIDC)[^4]처럼 인증 과정(로그인) 후에 접근 토큰을 발급하는 방식으로 인증 흐름에 통합되어 사용되는 경우가 많다.

###### JWT (JSON Web Token)
* **개념**: 웹 표준([RFC 7519](https://tools.ietf.org/html/rfc7519))으로서, 두 개체 사이에서 **JSON 객체를 사용하여 정보를 안전하게 전송**하기 위한 간결하고 자체 포함적인(Self-contained) 방식이다. 주로 **인증 및 정보 교환**에 사용된다.
* **구조**: `.`으로 구분된 세 부분으로 구성된다.
    1.  **헤더 (Header)**: 토큰 타입(JWT)과 사용된 서명 알고리즘(예: HMAC SHA256, RSA) 정보를 담는다. Base64Url로 인코딩된다.
    2.  **페이로드 (Payload)**: 토큰에 담을 정보(Claim)를 포함한다. 사용자 ID, 이름, 권한, 만료 시간 등 필요한 데이터를 JSON 형태로 담는다. Base64Url로 인코딩된다. (페이로드 정보는 암호화된 것이 아니므로 민감 정보는 담지 않아야 함)
    3.  **서명 (Signature)**: 헤더와 페이로드를 합친 문자열을 비밀 키(Secret Key) 또는 개인 키(Private Key)를 사용하여 지정된 알고리즘으로 서명한 값이다. 토큰의 **무결성(Integrity)** 과 **인증(Authentication)** 을 보장한다. (서버는 이 서명을 검증하여 토큰이 위변조되지 않았는지, 신뢰할 수 있는 발급자인지 확인한다.)
* **작동 방식**:
    1.  사용자 로그인 성공 시, 서버는 사용자의 정보와 권한을 담은 JWT를 생성하고 서명하여 클라이언트에게 전달한다.
    2.  클라이언트는 JWT를 받아 저장(예: 로컬 스토리지, 쿠키)한다.
    3.  이후 API 요청 시 `Authorization: Bearer <jwt>` 헤더에 담아 서버로 전송한다.
    4.  서버는 수신된 JWT의 서명을 검증하고, 유효하다면 페이로드의 정보를 사용하여 사용자를 식별하고 권한을 확인한다.
* **장점**:
    * **Stateless & Scalability**: 토큰 자체에 필요한 정보가 있어 서버 상태 유지가 불필요하다.
    * **자기 포함적 (Self-contained)**: 토큰만으로 사용자 식별 및 권한 확인이 가능하다.
    * **다양한 환경 지원**: 웹, 모바일 등 다양한 환경에서 사용 가능하다.
    * **표준 기반**: 여러 언어와 프레임워크에서 라이브러리를 지원한다.
* **단점**:
    * 페이로드 정보는 인코딩될 뿐 암호화되지 않는다. (민감 정보 포함 주의)
    * 토큰 탈취 시 만료될 때까지 유효하므로 만료 시간을 짧게 설정하고, Refresh Token 메커니즘을 도입하는 것이 좋다.
    * 한 번 발급된 토큰은 만료 전까지 폐기하기 어렵다. (블랙리스트 관리 등의 추가 구현 필요)

JWT는 토큰 기반 인증에서 토큰의 형식으로 널리 사용되며, OAuth 2.0의 Access Token이나 ID Token으로도 활용될 수 있다.

---

## API 키 관리 & 보안 고려사항

서버 간 통신이나 특정 클라이언트를 식별하여 API 사용량을 추적하거나 기본적인 접근 제어를 위해 **API 키(API Key)** 를 사용하기도 한다.

###### API 키
* **개념**: API 제공자가 클라이언트에게 발급하는 고유한 식별 문자열이다. 주로 서버 간 통신이나 특정 프로젝트/애플리케이션을 식별하는 데 사용된다.
* **사용 방식**: 보통 요청 헤더(`X-API-Key: <api-key>`)나 쿼리 매개변수(`?apiKey=<api-key>`)를 통해 전달된다.
* **주의점**:
    * API 키는 사용자 인증(Authentication)보다는 **프로젝트나 애플리케이션 식별 및 기본적인 인가** 목적에 가깝다. 사용자별 세밀한 권한 제어에는 적합하지 않다.
    * 단순 문자열이므로 **탈취 및 노출에 매우 취약**하다. 절대 클라이언트 측 코드(예: Javascript)에 하드코딩하거나 공개된 저장소에 포함시키면 안 된다.
    * API 키는 주기적으로 교체하고, 사용하지 않는 키는 비활성화/삭제해야 한다.
    * IP 주소 제한 등 추가적인 보안 장치를 함께 사용하는 것이 좋다.

###### 일반적인 보안 고려사항
* **HTTPS 사용**: 모든 API 통신은 **HTTPS를 통해 암호화**되어야 한다. 이를 통해 중간자 공격(Man-in-the-Middle Attack)으로부터 데이터를 보호하고, Basic Auth나 토큰, API 키의 탈취 위험을 줄일 수 있다.
* **입력값 검증 (Input Validation)**: 클라이언트로부터 받는 모든 입력값(경로 매개변수, 쿼리 매개변수, 요청 본문 등)은 반드시 **엄격하게 검증**해야 한다. SQL Injection, Cross-Site Scripting (XSS) 등 다양한 공격을 방지하는 기본이다.
* **요청 속도 제한 (Rate Limiting)**: 악의적인 사용자나 비정상적인 트래픽으로부터 서버를 보호하기 위해 특정 시간 동안 허용되는 요청 횟수를 제한해야 한다. (예: 분당 100회 요청 제한)
* **최소 권한 원칙 (Principle of Least Privilege)**: 사용자나 시스템에게 꼭 필요한 최소한의 권한만 부여해야 한다. 불필요한 권한은 잠재적인 보안 위협이 될 수 있다.
* **민감 정보 로깅 금지**: 로그 파일에 비밀번호, 토큰, API 키 등 민감한 정보가 기록되지 않도록 주의해야 한다.
* **보안 헤더 사용**: `Strict-Transport-Security`, `X-Content-Type-Options`, `X-Frame-Options`, `Content-Security-Policy` 등 보안 관련 HTTP 헤더를 적절히 사용하여 웹 브라우저 단에서의 보안을 강화할 수 있다.
* **정기적인 보안 감사 및 취약점 점검**: API 보안은 지속적인 노력이 필요하다. 정기적인 코드 검토, 보안 감사, 모의 해킹 등을 통해 잠재적인 취약점을 발견하고 개선해야 한다.

[^1]: 상태 비저장(Stateless) 방식은 어떤 서버로 요청이 분산되든 상관없이 요청을 처리할 수 있기 때문에 서버 확장에 유리하다.
[^2]: [OAuth2.1](https://oauth.net/2.1/)에서 Implicit Grant와 Resource Owner Password Credentials Grant는 삭제되었음을 확인할 수 있다.
[^3]: [OAuth2.1](https://oauth.net/2.1/), [RFC 8252 “OAuth 2.0 for Native Apps”](https://datatracker.ietf.org/doc/html/rfc8252#section-6)에서 권장하고 있는 것을 확인할 수 있다.
[^4]: OpenID Connect는 OAuth 2.0 기반의 인증 계층.