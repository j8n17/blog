API 엔드포인트(Endpoint)의 주소 역할을 하는 URI(Uniform Resource Identifier)의 설계는 API의 사용성과 유지보수성에 큰 영향을 미친다. 잘 설계된 URI는 직관적이고 예측 가능하며, 리소스를 명확하게 표현한다.

---

## URI 기본 개념과 특징

* **URI (Uniform Resource Identifier)**: 인터넷 상의 자원(Resource)을 고유하게 식별하고 위치를 지정하는 문자열이다. 우리가 흔히 웹 주소라고 부르는 URL(Uniform Resource Locator)은 URI의 가장 일반적인 형태이다.
* **리소스 (Resource)**: URI가 식별하는 대상이다. 웹 페이지, 이미지, 데이터, 서비스 등 네트워크를 통해 접근 가능한 모든 것을 리소스라고 할 수 있다. REST API에서는 주로 데이터나 객체를 리소스로 다룬다. (예: 사용자 목록, 특정 게시글)
* **특징**:
    * **명확성**: 잘 설계된 URI는 해당 URI가 가리키는 리소스가 무엇인지 명확하게 전달한다.
    * **일관성**: 일관된 규칙으로 URI를 설계하면 API 사용자가 쉽게 구조를 파악하고 예측할 수 있다.
    * **가독성**: 사람이 읽고 이해하기 쉬운 URI는 개발 및 디버깅 과정을 용이하게 한다.
    * **독립성**: URI 설계는 기본적으로 서버 구현과 독립적이어야 한다. 즉, URI만 보고 내부 구현 기술(예: Java, Python)이나 데이터베이스 구조를 유추할 수 없어야 한다.

###### URI, URL, URN 관계
URI는 식별자(Identifier)를 의미하는 가장 큰 개념이다.

URL(Locator)은 리소스의 위치를 나타내고, URN(Name)은 리소스의 이름을 나타낸다. 즉, URL과 URN은 모두 URI의 하위 개념이며, 모든 URL과 URN은 URI이지만 모든 URI가 URL 또는 URN인 것은 아니다. 

예를 들어 `mailto:someone@example.com`은 리소스의 위치(URL)보다는 이름(URN)에 가까운 URI이다. 웹 API 설계에서는 주로 위치를 나타내는 URL 형태의 URI를 사용한다.

---

## URI 기본 구조

[RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-3)에서 정의하는 URI의 구조는 다음과 같다.

```
<scheme>://<authority><path>?<query>#<fragment>
```

* **`scheme`**: 리소스에 접근하는 데 사용할 프로토콜 (예: `http`, `https`, `ftp`). API에서는 주로 `https`를 사용한다.
* **`authority`**: 리소스에 접근할 수 있는 권한을 가진 주체(서버)를 식별한다. 일반적으로 `[userinfo@]host[:port]` 형태로 구성된다.
    * `userinfo`: 사용자 정보 (선택 사항)
    * `host`: 리소스가 위치한 서버의 도메인 이름 또는 IP 주소 (예: `api.example.com`).
    * `port`: 서버에 접속하기 위한 포트 번호. 기본 포트(http: 80, https: 443)는 생략 가능하다.
* **`path`**: 서버 내에서 리소스의 구체적인 경로를 나타낸다. REST API 설계에서 리소스의 계층 구조를 표현한다. (예: `/users/123/orders`)
* **`query`**: `?` 뒤에 오는 문자열로, `key=value` 쌍으로 구성된다. 리소스에 대한 추가적인 매개변수(필터링, 정렬, 검색 조건 등)를 전달하는 데 사용된다. 각 쌍은 `&`로 구분된다. (예: `?status=completed&sort=date_desc`)
* **`fragment`**: `#` 뒤에 오는 문자열로, 리소스 내의 특정 부분을 가리킨다. 주로 웹 브라우저에서 사용되며, 서버에는 전달되지 않는다. API 설계에서는 거의 사용되지 않는다.

API 설계 시에는 주로 `path`와 `query` 부분을 어떻게 구성할지에 집중하게 된다.

---

## 리소스 네이밍 컨벤션

URI 경로(`path`)에서 리소스를 표현하는 방식에 대한 몇 가지 일반적인 규칙과 고려사항이 있다.

* **명사 사용**: 리소스는 명사로 표현하는 것이 좋다. 동사(행위)는 HTTP 메서드(`GET`, `POST`, `PUT`, `DELETE` 등)로 표현한다.
    * 좋은 예: `/users`, `/products`
    * 나쁜 예: `/getUsers`, `/createProduct`
* **계층 구조 표현**: 리소스 간의 관계나 포함 관계는 `/`를 사용하여 계층적으로 표현한다.
    * 예: `/users/{userId}/orders` (특정 사용자의 주문 목록)
    * 예: `/products/{productId}/reviews` (특정 상품의 리뷰 목록)

### 복수형 vs 단수형

컬렉션(Collection) 리소스를 표현할 때 복수형 명사를 사용할지, 단수형 명사를 사용할지에 대한 논쟁이 있다.

* **복수형 (Plural)**: `/users`, `/products`
    * **장점**: 컬렉션임을 명확히 나타내며, `/users/{userId}` 와 같이 개별 리소스 식별자와의 관계가 자연스럽다. 가장 널리 권장되는 방식이다.
    * **예시**:
        * `GET /users` : 모든 사용자 목록 조회
        * `GET /users/123` : ID가 123인 사용자 정보 조회
        * `POST /users` : 새로운 사용자 생성
* **단수형 (Singular)**: `/user`, `/product`
    * **장점**: 일부 개발자는 단수형이 더 직관적이라고 생각할 수 있다.
    * **단점**: `/user/{userId}` 형태가 어색하게 느껴질 수 있으며, 컬렉션과 개별 리소스의 구분이 모호해질 수 있다.

**권장**: 일관성을 위해 **복수형** 사용을 권장한다.

### 케밥-케이스(-) vs 스네이크-케이스(_)

URI 경로에서 여러 단어로 구성된 리소스 이름을 표현할 때 단어 구분자로 하이픈(`-`)을 사용할지, 밑줄(`_`)을 사용할지에 대한 선택이다.

* **케밥-케이스 (kebab-case)**: `/user-profiles`, `/product-categories`
    * **장점**: 가독성이 좋으며, DNS 이름 지정 규칙과 유사하여 일반적으로 웹에서 더 많이 사용된다. RFC 3986 (URI 표준)에서는 하이픈 사용을 권장한다.
* **스네이크-케이스 (snake_case)**: `/user_profiles`, `/product_categories`
    * **장점**: 일부 프로그래밍 언어의 변수 명명 규칙과 유사하여 익숙할 수 있다.
    * **단점**: 일부 시스템이나 컨텍스트에서 밑줄이 특별한 의미를 가질 수 있으며, 하이픈에 비해 가독성이 떨어진다는 의견도 있다.

**권장**: **케밥-케이스(-)** 사용을 권장한다. 하지만 가장 중요한 것은 프로젝트 내에서 일관성을 유지하는 것이다.

---

## 버전 관리 전략

API의 기능 변경이나 응답 구조 변화 등으로 인해 하위 호환성이 깨지는 변경(Breaking Change)이 발생할 경우, 기존 클라이언트가 오류 없이 계속 작동하도록 보장하면서 새로운 버전의 API를 도입하는 방법이 필요하다.

URI 또는 요청 방식을 통한 명시적인 버전 관리는 이를 가능하게 하는 핵심 전략이며, 클라이언트가 특정 API 버전을 선택하여 호출할 수 있도록 한다.

### URI 경로 기반 (Path Versioning)

URI 경로에 버전 정보를 포함하는 가장 일반적인 방식이다.

* **예시**: `https://api.example.com/v1/users`, `https://api.example.com/v2/users`
* **장점**:
    * 직관적이고 명확하다. 브라우저에서도 쉽게 테스트할 수 있다.
    * 버전별로 라우팅 및 코드 분리가 용이하다.
* **단점**:
    * 버전이 변경될 때마다 URI가 변경된다. (REST 원칙 중 '동일한 리소스는 동일한 URI를 가져야 한다'는 관점에서 비판받기도 함)
    * URI가 다소 길어질 수 있다.

### 헤더 기반 (Header Versioning)

HTTP 요청 헤더에 사용자 정의 헤더(예: `Accept-Version`)나 `Accept` 헤더를 이용하여 버전을 명시하는 방식이다.

* **예시 (사용자 정의 헤더)**: `Accept-Version: v1`
* **예시 (Accept 헤더)**: `Accept: application/vnd.example.v1+json` (미디어 타입 기반과 유사)
* **장점**:
    * URI가 버전 정보로 오염되지 않아 깔끔하게 유지된다. ('동일 리소스, 동일 URI' 원칙 준수)
* **단점**:
    * 브라우저에서 직접 테스트하기 번거롭다. (별도의 도구나 코드 필요)
    * 헤더를 확인해야 버전을 알 수 있어 직관성이 떨어진다.

### 미디어 타입 기반 (Media Type Versioning)

`Accept` 요청 헤더와 `Content-Type` 응답 헤더에 버전 정보가 포함된 사용자 정의 미디어 타입을 사용하는 방식이다. 가장 RESTful 하다고 평가받기도 한다.

* **예시**:
    * 요청: `Accept: application/vnd.example.v1+json`
    * 응답: `Content-Type: application/vnd.example.v1+json`
* **장점**:
    * URI가 버전 정보로 오염되지 않는다.
    * HTTP 표준(콘텐츠 협상)을 활용하여 버전을 관리한다. 리소스의 특정 '표현(Representation)'을 요청하는 개념에 부합한다.
* **단점**:
    * 헤더 기반 방식과 마찬가지로 브라우저 테스트가 번거롭다.
    * 사용자 정의 미디어 타입 형식이 다소 복잡하게 느껴질 수 있다.

**선택 가이드**: 명확성과 편의성이 중요하다면 **URI 경로 기반**이 좋은 선택이다. REST 원칙을 더 엄격하게 따르고 싶다면 **헤더 기반**이나 **미디어 타입 기반**을 고려할 수 있다. 프로젝트의 특성과 팀의 선호도에 따라 적절한 방식을 선택하고 일관되게 적용하는 것이 중요하다. 